name: Full Deployment to AWS

on:
  workflow_dispatch:
    inputs:
      deploy_backend:
        description: 'Deploy Backend'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      deploy_frontend:
        description: 'Deploy Frontend'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      run_migrations:
        description: 'Run Database Migrations'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
  push:
    branches: [ main ]
    tags:
      - 'v*'

env:
  AWS_REGION: us-east-1

jobs:
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_backend != 'false') }}
    continue-on-error: false
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Verify AWS credentials
        run: |
          echo "Verifying AWS credentials..."
          aws sts get-caller-identity
          echo "‚úÖ AWS credentials verified"
      
      - name: Create ECR repository if it doesn't exist
        run: |
          echo "Checking if ECR repository exists..."
          if aws ecr describe-repositories --repository-names nonprofit-learning-backend --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "‚úÖ ECR repository 'nonprofit-learning-backend' already exists"
            aws ecr describe-repositories --repository-names nonprofit-learning-backend --region ${{ env.AWS_REGION }}
          else
            echo "Creating ECR repository 'nonprofit-learning-backend'..."
            aws ecr create-repository \
              --repository-name nonprofit-learning-backend \
              --region ${{ env.AWS_REGION }} \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability MUTABLE
            echo "‚úÖ ECR repository created successfully"
          fi
      
      - name: Verify ECR repository access
        run: |
          echo "Verifying ECR repository access..."
          aws ecr describe-repositories --repository-names nonprofit-learning-backend --region ${{ env.AWS_REGION }}
          echo "‚úÖ ECR repository is accessible"
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Display ECR registry info
        run: |
          echo "ECR Registry: ${{ steps.login-ecr.outputs.registry }}"
          echo "Repository URI: ${{ steps.login-ecr.outputs.registry }}/nonprofit-learning-backend"
      
      - name: Verify Dockerfile and entrypoint exist
        working-directory: ./backend
        run: |
          if [ ! -f "Dockerfile" ]; then
            echo "‚ùå Dockerfile not found in backend directory"
            exit 1
          fi
          if [ ! -f "entrypoint.sh" ]; then
            echo "‚ö†Ô∏è  entrypoint.sh not found, creating a basic one..."
            cat > entrypoint.sh <<'EOF'
          #!/bin/bash
          set -e
          echo "Starting application..."
          exec "$@"
          EOF
            chmod +x entrypoint.sh
          fi
          echo "‚úÖ Dockerfile and entrypoint.sh verified"
      
      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: nonprofit-learning-backend
          IMAGE_TAG: ${{ github.sha }}
        working-directory: ./backend
        run: |
          set -e
          FULL_IMAGE_TAG="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          LATEST_IMAGE_TAG="$ECR_REGISTRY/$ECR_REPOSITORY:latest"
          
          echo "=========================================="
          echo "Building Docker image..."
          echo "Image: $FULL_IMAGE_TAG"
          echo "=========================================="
          
          docker build -t $FULL_IMAGE_TAG . || {
            echo "‚ùå Docker build failed"
            echo "Checking Dockerfile..."
            cat Dockerfile || echo "Dockerfile not found"
            exit 1
          }
          
          echo "‚úÖ Docker image built successfully"
          echo "Tagging as latest: $LATEST_IMAGE_TAG"
          docker tag $FULL_IMAGE_TAG $LATEST_IMAGE_TAG
          
          echo "=========================================="
          echo "Pushing images to ECR..."
          echo "Pushing: $FULL_IMAGE_TAG"
          echo "=========================================="
          docker push $FULL_IMAGE_TAG || {
            echo "‚ùå Failed to push image tag: $FULL_IMAGE_TAG"
            echo "Checking ECR repository..."
            aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region ${{ env.AWS_REGION }} || echo "Repository check failed"
            exit 1
          }
          
          echo "Pushing: $LATEST_IMAGE_TAG"
          docker push $LATEST_IMAGE_TAG || {
            echo "‚ùå Failed to push latest tag: $LATEST_IMAGE_TAG"
            exit 1
          }
          
          echo "=========================================="
          echo "‚úÖ Images pushed successfully!"
          echo "Image URI: $FULL_IMAGE_TAG"
          echo "Latest URI: $LATEST_IMAGE_TAG"
          echo "=========================================="
          
          # Verify images in ECR
          echo "Verifying images in ECR..."
          aws ecr list-images --repository-name $ECR_REPOSITORY --region ${{ env.AWS_REGION }} || echo "Image listing failed (may be normal)"
      
      - name: Deploy to EC2
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: nonprofit-learning-backend
          IMAGE_TAG: latest
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          EC2_SSH_PORT: ${{ secrets.EC2_SSH_PORT || '22' }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          CLERK_FRONTEND_API: ${{ secrets.CLERK_FRONTEND_API }}
          CORS_ORIGINS: ${{ secrets.CORS_ORIGINS || '*' }}
        run: |
          set -e
          if [ -z "$EC2_HOST" ] || [ -z "$EC2_USER" ] || [ -z "$EC2_SSH_KEY" ]; then
            echo "‚ùå Missing EC2 deployment secrets"
            echo "   Required: EC2_HOST, EC2_USER, EC2_SSH_KEY"
            exit 1
          fi

          echo "Setting up SSH key..."
          mkdir -p ~/.ssh
          echo "$EC2_SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p "$EC2_SSH_PORT" -H "$EC2_HOST" >> ~/.ssh/known_hosts

          echo "Deploying to EC2..."
          ssh -p "$EC2_SSH_PORT" "$EC2_USER@$EC2_HOST" <<EOF
          set -e
          echo "‚úÖ Connected to EC2"

          # Ensure Docker is installed
          if ! command -v docker >/dev/null 2>&1; then
            echo "‚ùå Docker is not installed on EC2"
            exit 1
          fi

          # Login to ECR (requires EC2 instance role with ECR read access)
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REGISTRY

          # Pull latest image
          docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

          # Stop and remove old container if exists
          docker stop nonprofit-learning-backend || true
          docker rm nonprofit-learning-backend || true

          # Run new container
          docker run -d \
            --name nonprofit-learning-backend \
            --restart unless-stopped \
            -p 8000:8000 \
            -e DATABASE_URL="$DATABASE_URL" \
            -e CLERK_SECRET_KEY="$CLERK_SECRET_KEY" \
            -e CLERK_PUBLISHABLE_KEY="$CLERK_PUBLISHABLE_KEY" \
            -e CLERK_FRONTEND_API="$CLERK_FRONTEND_API" \
            -e ENVIRONMENT="production" \
            -e CORS_ORIGINS="$CORS_ORIGINS" \
            $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

          echo "‚úÖ EC2 deployment completed"
          EOF

  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_frontend != 'false') }}
    needs: deploy-backend
    continue-on-error: true
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install dependencies
        working-directory: ./frontend
        run: |
          echo "Installing dependencies..."
          # Clear any npm authentication issues and set to public registry
          rm -f ~/.npmrc
          npm config delete //registry.npmjs.org/:_authToken || true
          npm config set registry https://registry.npmjs.org/
          
          # Replace private registry URLs in package-lock.json with public registry
          if [ -f "package-lock.json" ]; then
            echo "Replacing private registry URLs with public npm registry..."
            sed -i 's|https://mckinsey.jfrog.io/artifactory/api/npm/npm/|https://registry.npmjs.org/|g' package-lock.json || true
          fi
          
          # Since package-lock.json is out of sync, always use npm install
          # This will regenerate the lock file with correct versions
          echo "‚ö†Ô∏è  package-lock.json is out of sync, regenerating it..."
          rm -f package-lock.json
          npm install --legacy-peer-deps --no-audit
          echo "‚úÖ Dependencies installed (lock file regenerated)"
      
      - name: Build Next.js app
        working-directory: ./frontend
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL || 'http://localhost:8000' }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY || 'pk_test_placeholder' }}
          NEXT_PUBLIC_CLERK_FRONTEND_API: ${{ secrets.CLERK_FRONTEND_API || 'https://placeholder.clerk.accounts.dev' }}
          # Note: Not using NEXT_OUTPUT=export because Clerk requires dynamic rendering
        run: |
          echo "Building Next.js application (dynamic rendering for Clerk)..."
          npm run build
          echo "‚úÖ Build completed successfully"
          echo "Build output location: out/"
          ls -la out/ || echo "out/ directory not found"
      
      - name: Create S3 bucket if it doesn't exist
        run: |
          if ! aws s3 ls s3://nonprofit-learning-frontend 2>/dev/null; then
            echo "Creating S3 bucket..."
            aws s3 mb s3://nonprofit-learning-frontend --region ${{ env.AWS_REGION }}
            echo "‚úÖ S3 bucket created"
          else
            echo "‚úÖ S3 bucket already exists"
          fi
      
      - name: Configure S3 bucket for static website hosting
        run: |
          echo "Configuring S3 bucket for static website hosting..."
          aws s3 website s3://nonprofit-learning-frontend \
            --index-document index.html \
            --error-document index.html || echo "Website configuration may already exist"
          
          # Set bucket policy for public read access
          cat > /tmp/bucket-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "PublicReadGetObject",
                "Effect": "Allow",
                "Principal": "*",
                "Action": "s3:GetObject",
                "Resource": "arn:aws:s3:::nonprofit-learning-frontend/*"
              }
            ]
          }
          EOF
          aws s3api put-bucket-policy \
            --bucket nonprofit-learning-frontend \
            --policy file:///tmp/bucket-policy.json || echo "Bucket policy may already exist"
          
          # Remove public access block
          aws s3api put-public-access-block \
            --bucket nonprofit-learning-frontend \
            --public-access-block-configuration \
            "BlockPublicAcls=false,IgnorePublicAcls=false,BlockPublicPolicy=false,RestrictPublicBuckets=false" || true
          
          echo "‚úÖ S3 bucket configured"
      
      - name: Deploy to S3
        working-directory: ./frontend
        run: |
          echo "‚ö†Ô∏è  Note: Next.js with Clerk requires dynamic rendering"
          echo "This means we can't use pure static export to S3"
          echo ""
          echo "Options:"
          echo "1. Deploy .next/standalone to App Runner or EC2 (recommended)"
          echo "2. Use CloudFront + Lambda@Edge for dynamic rendering"
          echo "3. Use AWS Amplify (supports Next.js dynamic rendering)"
          echo ""
          echo "For now, we'll export what we can for S3..."
          
          # Check if .next directory exists (dynamic build)
          if [ -d ".next" ]; then
            echo "‚úÖ Dynamic build completed (.next directory found)"
            echo ""
            echo "To deploy this, you need a Node.js server:"
            echo "- App Runner: Deploy .next/standalone"
            echo "- EC2: Run 'npm start' from .next/standalone"
            echo "- Or use AWS Amplify for full Next.js support"
            echo ""
            echo "‚ö†Ô∏è  Skipping S3 deployment - requires server-side rendering"
            echo "üí° Consider deploying frontend to App Runner instead of S3"
          elif [ -d "out" ]; then
            echo "Static export found, deploying to S3..."
            aws s3 sync out/ s3://nonprofit-learning-frontend/ \
              --delete \
              --cache-control "public, max-age=0, must-revalidate" \
              --exclude "*.map"
            echo "‚úÖ Files deployed to S3"
          else
            echo "‚ùå No build output found!"
            ls -la
            exit 1
          fi
      
      - name: Create or update CloudFront distribution
        continue-on-error: true
        run: |
          echo "Checking for existing CloudFront distribution..."
          
          # Check if distribution already exists
          DIST_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?contains(Origins.Items[0].DomainName, 'nonprofit-learning-frontend.s3')].Id" \
            --output text 2>/dev/null | head -1 || echo "")
          
          if [ -n "$DIST_ID" ] && [ "$DIST_ID" != "None" ]; then
            echo "‚úÖ CloudFront distribution already exists: $DIST_ID"
            echo "Distribution domain: $(aws cloudfront get-distribution --id $DIST_ID --query 'Distribution.DomainName' --output text 2>/dev/null || echo 'Unknown')"
          else
            echo "Creating CloudFront distribution..."
            
            # Get S3 bucket website endpoint
            S3_DOMAIN="nonprofit-learning-frontend.s3.${{ env.AWS_REGION }}.amazonaws.com"
            
            # Create CloudFront distribution
            DIST_CONFIG=$(cat <<EOF
          {
            "CallerReference": "nonprofit-learning-frontend-$(date +%s)",
            "Comment": "Nonprofit Learning Platform Frontend",
            "DefaultRootObject": "index.html",
            "Origins": {
              "Quantity": 1,
              "Items": [
                {
                  "Id": "S3-nonprofit-learning-frontend",
                  "DomainName": "$S3_DOMAIN",
                  "S3OriginConfig": {
                    "OriginAccessIdentity": ""
                  }
                }
              ]
            },
            "DefaultCacheBehavior": {
              "TargetOriginId": "S3-nonprofit-learning-frontend",
              "ViewerProtocolPolicy": "redirect-to-https",
              "AllowedMethods": {
                "Quantity": 2,
                "Items": ["GET", "HEAD"],
                "CachedMethods": {
                  "Quantity": 2,
                  "Items": ["GET", "HEAD"]
                }
              },
              "ForwardedValues": {
                "QueryString": false,
                "Cookies": {
                  "Forward": "none"
                }
              },
              "MinTTL": 0,
              "DefaultTTL": 3600,
              "MaxTTL": 86400,
              "Compress": true
            },
            "Enabled": true,
            "PriceClass": "PriceClass_100"
          }
          EOF
            )
            
            echo "$DIST_CONFIG" > /tmp/cloudfront-config.json
            
            DIST_OUTPUT=$(aws cloudfront create-distribution \
              --distribution-config file:///tmp/cloudfront-config.json \
              --region ${{ env.AWS_REGION }} 2>&1)
            
            if [ $? -eq 0 ]; then
              NEW_DIST_ID=$(echo "$DIST_OUTPUT" | grep -oP '"Id":\s*"\K[^"]+' | head -1 || echo "")
              NEW_DOMAIN=$(echo "$DIST_OUTPUT" | grep -oP '"DomainName":\s*"\K[^"]+' | head -1 || echo "")
              echo "‚úÖ CloudFront distribution created!"
              echo "Distribution ID: $NEW_DIST_ID"
              echo "Domain: $NEW_DOMAIN"
              echo ""
              echo "‚ö†Ô∏è  IMPORTANT: Add this to GitHub Secrets:"
              echo "   CLOUDFRONT_DISTRIBUTION_ID=$NEW_DIST_ID"
              echo ""
              echo "‚ö†Ô∏è  Note: Distribution deployment takes 5-15 minutes"
            else
              echo "‚ö†Ô∏è  CloudFront distribution creation failed"
              echo "$DIST_OUTPUT"
              echo "You can create it manually via AWS Console"
            fi
          fi
      
      - name: Invalidate CloudFront cache
        continue-on-error: true
        env:
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          if [ -n "$CLOUDFRONT_DISTRIBUTION_ID" ]; then
            echo "Invalidating CloudFront cache..."
            aws cloudfront create-invalidation \
              --distribution-id "$CLOUDFRONT_DISTRIBUTION_ID" \
              --paths "/*" || echo "CloudFront invalidation failed"
          else
            echo "‚ö†Ô∏è  CLOUDFRONT_DISTRIBUTION_ID not set, skipping CloudFront invalidation"
            echo "   Distribution will be invalidated automatically on next deployment"
          fi

  run-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_migrations != 'false') }}
    needs: deploy-backend
    continue-on-error: true
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Run migrations
        working-directory: ./backend
        continue-on-error: true
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          CLERK_FRONTEND_API: ${{ secrets.CLERK_FRONTEND_API }}
          ENVIRONMENT: production
          CORS_ORIGINS: ${{ secrets.CORS_ORIGINS || '*' }}
        run: |
          if [ -z "$DATABASE_URL" ]; then
            echo "‚ö†Ô∏è  DATABASE_URL not set, skipping migrations"
            echo "‚ÑπÔ∏è  Note: Database needs to be created first (RDS PostgreSQL)"
            echo "‚ÑπÔ∏è  You can create it using Terraform or AWS Console"
            echo "‚ÑπÔ∏è  Then add DATABASE_URL to GitHub Secrets"
            exit 0
          fi
          
          # Validate required Clerk environment variables
          if [ -z "$CLERK_SECRET_KEY" ] || [ -z "$CLERK_PUBLISHABLE_KEY" ] || [ -z "$CLERK_FRONTEND_API" ]; then
            echo "‚ùå Missing required Clerk environment variables for migrations"
            echo "   Please set CLERK_SECRET_KEY, CLERK_PUBLISHABLE_KEY, and CLERK_FRONTEND_API in GitHub Secrets"
            exit 1
          fi
          
          echo "Running database migrations..."
          alembic upgrade head || {
            echo "‚ö†Ô∏è  Migrations failed but continuing..."
            echo "This is expected if the database doesn't exist yet"
            exit 0
          }
          echo "‚úÖ Migrations completed"

  notify:
    name: Deployment Complete
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend, run-migrations]
    if: always()
    
    steps:
      - name: Deployment status
        run: |
          echo "‚úÖ Deployment pipeline completed"
          echo "Backend: ${{ needs.deploy-backend.result }}"
          echo "Frontend: ${{ needs.deploy-frontend.result }}"
          echo "Migrations: ${{ needs.run-migrations.result }}"
